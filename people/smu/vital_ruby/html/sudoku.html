<!DOCTYPE html>
<html>
  <head>
    <title>Vital Ruby Projects</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="description" content="Project descriptions for the EdgeCase Vital Testing workshop." />
    <link rel="stylesheet" type="text/css" href="stylesheets/projects.css" media="all" />
    <script type="text/javascript" src="javascripts/jquery.js"></script>
    <script type="text/javascript" src="javascripts/projects.js"></script>
  </head>
  <body>
    <div id="page">
      <div id="content">
        <h1>Project B: Sudoku Solver</h1>

<h2>Goals</h2>

<ul>
<li>Design and build a full Ruby program</li>
</ul>


<h2>Discussion</h2>

<p>Write a program that solves Sudoku problem.</p>

<p>From <a href="http://en.wikipedia.org/wiki/Sudoku">Wikipedia</a>:</p>

<blockquote>
  Sudoku is a logic-based, combinatorial number-placement
  puzzle. The objective is to fill a 9×9 grid with digits so that
  each column, each row, and each of the nine 3×3 sub-grids that
  comprise the grid (also called "boxes", "blocks", "regions", or
  "sub-squares") contains all of the digits from 1 to 9. The puzzle
  setter provides a partially completed grid. Completed puzzles are
  usually a type of Latin square with an additional constraint on the
  contents of individual regions.
</blockquote>


<p>For example, given the starting puzzle ("." indicates an empty
square):</p>

<pre><code>. 2 5  6 . .  4 9 .
7 . .  . 2 .  . . .
. 8 4  . 3 7  6 . .

5 . 9  . . .  . 3 .
1 . 2  3 . 5  8 . 9
. 3 .  . . .  2 . 4

. . 3  8 5 .  9 2 .
. . .  . 9 .  . . 3
. 9 1  . . 3  5 7 .
</code></pre>

<p>A solution would be:</p>

<pre><code>3 2 5  6 1 8  4 9 7
7 1 6  9 2 4  3 8 5
9 8 4  5 3 7  6 1 2

5 6 9  4 8 2  7 3 1
1 4 2  3 7 5  8 6 9
8 3 7  1 6 9  2 5 4

4 7 3  8 5 1  9 2 6
2 5 8  7 9 6  1 4 3
6 9 1  2 4 3  5 7 8
</code></pre>

<p>The input to your sudoku solver will be a puzzle file.  A puzzle file
will contain 91 digits and/or periods.  Each digit in the puzzle file
represents the starting value for single digit square of the puzzle.
A period indicates that particular single digit square has no starting
value.</p>

<p>White space (spaces, tabs and new lines) may be included in the puzzle
file for formatting, but may be ignored by the solver.</p>

<p>Lines in the puzzle file that begin with "#" are comments and should
be ignored.</p>

<p>Here's an example puzzle file for the above example:</p>

<pre>
.256..49.
7...2....
.84.376..
5.9....3.
1.23.58.9
.3....2.4
..385.92.
....9...3
.91..357.
</pre>


<p>The solver should display (at least) the initial puzzle and the final
solution.  Additional output showing the progess in reaching the
solution is OK, but not required.</p>

<p>The puzzles directory in the project area has a number of puzzles to
try out.  The easy1.sud puzzle is used in the examples above.</p>

<h3>Example Puzzles</h3>

<h4>easy1.sud (click to view)</h4>

<div class="solution">

<pre><code>.256..49.
7...2....
.84.376..
5.9....3.
1.23.58.9
.3....2.4
..385.92.
....9...3
.91..357.
</code></pre>

</div>

<h4>medium.sud (click to view)</h4>

<div class="solution">

<pre><code># http://www.websudoku.com/?level=2&amp;set_id=3350218628
.4...7.3.
..85..1..
.15.3..9.
5...7.21.
..6...8..
.81.6...9
.2..4.57.
..7..29..
.5.7...8.
</code></pre>

</div>

<h4>evil.sud (click to view)</h4>

<div class="solution">

<pre><code># http://www.websudoku.com/?level=4&amp;set_id=470872047
..53.694.
.3.1....6
.......3.
7..9.....
.1..3..2.
.....2..7
.6.......
8....7.5.
.436.81..
</code></pre>

</div>

<h4>evil2.sud (click to view)</h4>

<div class="solution">

<pre><code>..521....
72.......
.1.45..6.
..8....4.
5...8...3
.6....2..
.5..38.1.
.......97
....695..
</code></pre>

</div>

<h4>evil3.sud (click to view)</h4>

<div class="solution">

<pre><code>7..49.2..
..2..3...
.5.2...8.
8.....4..
2...3...9
..7.....8
.6...1.5.
...3..8..
..5.64..3
</code></pre>

</div>

<h4>evil4.sud (click to view)</h4>

<div class="solution">

<pre><code>....458..
....2...9
687..9...
.......95
.61...72.
72.......
...5..274
8...3....
..419....
</code></pre>

</div>

<h4>evil5.sud (click to view)</h4>

<div class="solution">

<pre><code>6..2....1
...6374..
.8.......
3..8.259.
.........
.429.6..7
.......1.
..3728...
5....4..9
</code></pre>

</div>

<h4>evil6.sud (click to view)</h4>

<div class="solution">

<pre><code>.64.3..1.
....486.9
.........
1.....9.8
.3..1..6.
4.7.....3
.........
9.537....
.4..8.23.
</code></pre>

</div>

<h4>empty.sud (click to view)</h4>

<div class="solution">

<pre><code>.........
.........
.........
.........
.........
.........
.........
.........
.........
</code></pre>

</div>

<h4>wiki.sud (click to view)</h4>

<div class="solution">

<pre><code># http://en.wikipedia.org/wiki/Sudoku
53..7....
6..195...
.98....6.
8...6...3
4..8.3..1
7...2...6
.6....28.
...419..5
....8..79
</code></pre>

</div>

<h4>wiki_dos.sud (click to view)</h4>

<div class="solution">

<pre><code># http://en.wikipedia.org/wiki/Sudoku
53..7....
6..195...
.98....6.
8...6...3
4..8.3..1
7...2...6
.6....28.
...419..5
....8..79
</code></pre>

</div>

<h3>Hints</h3>

<h4>Hint -- Source and Test for a Sudoku Solver</h4>

<div class="solution">

<p><strong>sudoku_test.rb</strong></p>

<pre><code>require 'rubygems'
require 'test/unit'
require 'shoulda'

require 'sudoku'

class CellTest &lt; Test::Unit::TestCase
  def create_group_with(cell, *numbers)
    g = Group.new
    g &lt;&lt; cell
    numbers.each do |n|
      c = Cell.new
      c.number = n
      g &lt;&lt; c
    end
    g
  end

  context 'a cell' do
    setup do
      @cell = Cell.new("C25")
    end

    should 'know its name' do
      assert_equal "C25", @cell.to_s
    end

    should 'be inspectable' do
      assert_equal "C25", @cell.inspect
    end

    should 'initially have no number' do
      assert_nil @cell.number
    end

    should 'be able to set number' do
      @cell.number = 4
      assert_equal 4, @cell.number
    end

    should 'accept a zero as no number' do
      @cell.number = 0
      assert_nil @cell.number
    end

    should 'report all numbers are available' do
      assert_equal( Set[*(1..9)], @cell.available_numbers )
    end

    context 'within a group' do
      setup do
        @group = create_group_with(@cell, 3, 4, 5)
      end

      should 'report available numbers not in the group' do
        assert_equal Set[1, 2, 6, 7, 8, 9], @cell.available_numbers
      end

      should 'report no available numbers if a number has been assigned' do
        @cell.number = 6
        assert_equal Set[], @cell.available_numbers
      end

    end
  end
end


class GroupTest &lt; Test::Unit::TestCase
  context 'a group of cells' do
    setup do
      @group = Group.new
    end

    should 'exist' do
      assert_not_nil @group
    end

    context 'with cells' do
      setup do
        @cells = (1..10).map { |i| Cell.new("C#{i}") }
        @cells.each do |c| @group &lt;&lt; c end
      end

      should 'give a list of numbers' do
        assert_equal Set[], @group.numbers
      end

      context 'with some numbers' do
        setup do
          @cells[0].number = 3
          @cells[3].number = 6
        end

        should 'give a list of the remaining missing numbers' do
          assert_equal [3, 6], @group.numbers.sort
        end
      end

    end

  end
end

module Puzzles
  Wiki =
    "53  7    " +
    "6  195   " +
    " 98    6 " +
    "8   6   3" +
    "4  8 3  1" +
    "7   2   6" +
    " 6    28 " +
    "   419  5" +
    "    8  79"

  Medium =
    " 4   7 3 " +
    "  85  1  " +
    " 15 3  9 " +
    "5   7 21 " +
    "  6   8  " +
    " 81 6   9" +
    " 2  4 57 " +
    "  7  29  " +
    " 5 7   8 "

  Evil =
    "  53 694 " +
    " 3 1    6" +
    "       3 " +
    "7  9     " +
    " 1  3  2 " +
    "     2  7" +
    " 6       " +
    "8    7 5 " +
    " 436 81  "
end

class BoardTest &lt; Test::Unit::TestCase
  include Puzzles

  context 'a board' do
    setup do
      @board = Board.new
    end

    should 'be inspectable' do
      assert_match %r(^&lt;Board \.{81}&gt;$), @board.inspect
    end

    should 'initially give all 9 numbers for all cells' do
      @board.each do |cell|
        assert_equal((1..9).to_a, cell.available_numbers.sort)
      end
    end

    should 'parse a string representation of the puzzle' do
      @board.parse(Wiki)
      assert_equal "5 3 .  . 7 .  . . .  \n" +
        "6 . .  1 9 5  . . .  \n" +
        ". 9 8  . . .  . 6 .  \n\n" +
        "8 . .  . 6 .  . . 3  \n" +
        "4 . .  8 . 3  . . 1  \n" +
        "7 . .  . 2 .  . . 6  \n\n" +
        ". 6 .  . . .  2 8 .  \n" +
        ". . .  4 1 9  . . 5  \n" +
        ". . .  . 8 .  . 7 9  \n\n",
        @board.to_s
    end

    should 'solve the Wikipedia Puzzle' do
      board = Board.new.parse(Wiki)
      board.solve

      assert board.solved?
      assert_equal "534678912672195348198342567" +
        "859761423426853791713924856" +
        "961537284287419635345286179",
        board.encoding
    end

    should 'solve the Wikipedia Puzzle with DOS line endings' do
      board = Board.new.parse(open("../puzzles/wiki_dos.sud") { |f| f.read })
      board.solve

      assert board.solved?
      assert_equal "534678912672195348198342567" +
        "859761423426853791713924856" +
        "961537284287419635345286179",
        board.encoding
    end

    should 'solve the Medium Puzzle' do
      board = Board.new.parse(Medium)
      board.solve

      assert board.solved?
      assert_equal "942187635368594127715236498" +
        "593478216476921853281365749" +
        "829643571137852964654719382",
        board.encoding
    end

    should 'solve the Evil Puzzle' do
      board = Board.new.parse(Evil)
      board.solve

      assert board.solved?
      assert_equal "285376941439125786176849235" +
        "752981364618734529394562817" +
        "567213498821497653943658172",
        board.encoding
    end

  end
end

class SudokuSolverTest &lt; Test::Unit::TestCase
  WikiPuzzleFile = '../puzzles/wiki.sud'
      SOLUTION = %{5 3 4  6 7 8  9 1 2
6 7 2  1 9 5  3 4 8
1 9 8  3 4 2  5 6 7

8 5 9  7 6 1  4 2 3
4 2 6  8 5 3  7 9 1
7 1 3  9 2 4  8 5 6

9 6 1  5 3 7  2 8 4
2 8 7  4 1 9  6 3 5
3 4 5  2 8 6  1 7 9}


  def redirect_output
    old_stdout = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = old_stdout
  end

  context 'a solver' do
    setup do
      @solver = SudokuSolver.new
    end

    should 'solve a puzzle' do
      result = redirect_output do
        @solver.run([WikiPuzzleFile])
      end
      assert_match(/#{SOLUTION}/, result)
    end

    should 'complain if no file given' do
      result = redirect_output do
        assert_raise(SystemExit) do
          @solver.run([])
        end
      end
      assert_match(/Usage:/, result)
    end
  end
end
</code></pre>

<p><strong>sudoku.rb</strong></p>

<pre><code>#!/usr/bin/env ruby

require 'set'

# A cell respresents a single location on the sudoku board.  Initially
# it holds no number, but a number can be manually assigned to the
# cell (which is then remembered for later).
#
# Each cell also belongs to 3 groups of cells, (1) the cells in its
# vertical column, (2) horizontal row, and (3) the 3x3 block of
# neighboring cells.  By looking at the cells in each of the groups,
# an individual cell can report on the list of possible numbers that
# are available for assignment to the cell. (If a cell already has an
# assigned number, the set of available numbers is empty).
#
class Cell
  attr_reader :number

  OneThruNine = Set[*1..9]

  # Initialize a cell with the name :name.
  def initialize(name="unamed")
    @name = name
    @groups = []
  end

  # Assign a number to the cell.  Assigning nil or 0 leaves the cell
  # unassigned.
  def number=(value)
    @number = value.nonzero?
  end

  # Return a set of numbers that could be assigned to the cell without
  # conflicting with any cells in any of the cell's groups.
  def available_numbers
    if number
      Set[]
    else
      @groups.inject(OneThruNine) { |res, group|
        res - group.numbers
      }
    end
  end

  # The cell joins the given group.
  def join(group)
    @groups &lt;&lt; group
  end

  # Provide a string representation of the cell.
  def to_s
    @name
  end

  # Provided an inspect string for the cell.
  def inspect
    to_s
  end
end


# Cells are organized into groups.  Each group consists of 9 cells
# where the number assigned to a cell must be unique within the group.
# Groups are able to report the current set of assigned numbers within
# the group.
class Group

  # Initialize a group.
  def initialize
    @cells = []
  end

  # Add a cell to the given group.  Make sure the cell knows that it
  # has joined the group.
  def &lt;&lt;(cell)
    cell.join(self)
    @cells &lt;&lt; cell
    self
  end

  # Return a set of numbers assigned to the cells in this group.
  def numbers
    Set[*@cells.map { |c| c.number }.compact]
  end
end

# A Sudoku board contains the 81 cells required by the puzzle.  The
# groupings of the cells is specified by the board in the
# :define_groups method.  The standard grouping is 9 row groups, 9
# column groups and 9 3x3 groups.
#
class Board
  include Enumerable

  # Initialize a board with a set of unassigned cells.
  def initialize(verbose=nil)
    @verbose = verbose
    @cells = (0...81).map { |i|
      Cell.new("C#{(i/9)+1}#{(i%9)+1}")
    }
    define_groups
  end

  # Parse an encoded puzzle string.  Spaces or periods ('.') are
  # treated as unassigned cells.  Newlines and tabs are ignored.
  def parse(string)
    numbers = string.gsub(/^#.*$/, '').gsub(/[\r\n\t]/, '').
      split(//).map { |n| n.to_i }
    each do |cell|
      cell.number = numbers.shift
    end
    self
  end

  # Iterate over the cells of the puzzle.  Iteration starts in the
  # upper left corner and continues across each row.
  def each
    @cells.each do |cell|
      yield cell
    end
  end

  # Has the puzzle been solved?  In other words, have all the cells
  # been assigned numbers?
  def solved?
    all? { |cell| cell.number }
  end

  # Are we stuck?  In other words, is there an unassigned cell where
  # there are no available numbers to be assigned to it.
  def stuck?
    any? { |cell| cell.number.nil? &amp;&amp; cell.available_numbers.size == 0 }
  end

  # Provide a human readable version of the board in a grid format.
  def to_s
    encoding.
      gsub(/.../, "\0 ").
      gsub(/.{12}/, "\0\n").
      gsub(/.{39}/m, "\0\n").
      gsub(/[\d.]/, "\0 ")
  end

  # Provide a inspect string for a board.
  def inspect
    "&lt;Board #{encoding}&gt;"
  end

  # Encode the board into an 81 character string.  Each character
  # represents the number stored in each cell.  Unassigned cells are
  # represented by a '.'.  Cells are ordered starting in the upper
  # left corner and sweeping first left to right across the row, and
  # then each successive row.
  def encoding
    map { |cell| cell.number || "." }.join
  end

  # Solve the puzzle represente by the board.  The solution algorithm
  # is roughly:
  #
  # * Put numbers in all the cells where there is only one
  #   possible choice (the _easy_ squares).
  # * If all cells have been assigned, then we are done!
  # * If all unassigned cells have no possibilities, then we
  #   are stuck.  Backtrack by restoring the state of the board
  #   to the last guess and make a different guess.  If there
  #   are no more alternatives, then we have failed to solve
  #   the puzzle.
  # * Otherwise, just pick one of the cells with the fewest
  #   possible numbers (to minimize backtracking) and just guess
  #   at one of the numbers.  Remember the other choices in
  #   case we need to backtrack.
  #
  def solve
    alternatives = []
    while true
      solve_easy_cells
      break if solved?
      if stuck?
        fail "No Solution Found" if alternatives.empty?
        say "Backtracking (#{alternatives.size})"
        guess(alternatives)
      else
        cell = find_candidate_for_guessing
        remember_alternatives(cell, alternatives)
        guess(alternatives)
      end
    end
  end

  private

  # Work toward a solution by assigning numbers to all the cells that
  # have only one possibility.
  def solve_easy_cells
    while solve_one_easy_cell
    end
  end

  # Find a cell with only one possibility and fill it.  Return true if
  # you are able to fill a square, otherwise return false.
  def solve_one_easy_cell
    each do |cell|
      an = cell.available_numbers
      if an.size == 1
        puts "Put #{an.to_a.first} at #{cell}" if @verbose
        cell.number = an.to_a.first
        return true
      end
    end
    return false
  end

  # Find a candidate cell for guessing.  The candidate must be an
  # unassigned cell.  Prefer cells with the fewest number of available
  # numbers (just to minimize backtracking).
  def find_candidate_for_guessing
    unassigned_cells.sort_by { |cell|
      [cell.available_numbers.size, to_s]
    }.first
  end

  # Return a list of unassigned cells on the board.
  def unassigned_cells
    to_a.reject { |cell| cell.number }
  end

  # Remember the all the alternative choices for the given cell on the
  # list of alternatives.  An alternative is stored as a 3-tuple
  # consisting of the current encoded state of the board, the cell and
  # an available number.
  def remember_alternatives(cell, alternatives)
    cell.available_numbers.each do |n|
      alternatives.push([encoding, cell, n])
    end
  end

  # Make a guess by pulling an alternative from the list of remembered
  # alternatives and.  The state of the board at the remembered
  # alternative is restored and the choice is made for that cell.
  def guess(alternatives)
    state, cell, number = alternatives.pop
    parse(state)
    say "Guessing #{number} at #{cell}"
    cell.number = number
  end

  # Define the groups of cells for this puzzle.  Override this method
  # if you wish to create board that support non-standard cell
  # groupings (such as http://www.websudoku.com/variation/?day=2)
  def define_groups
    define_columns
    define_rows
    define_blocks
  end

  # Define row groups.
  def define_rows
    define_groupings(
      "aaaaaaaaa" +
      "bbbbbbbbb" +
      "ccccccccc" +
      "ddddddddd" +
      "eeeeeeeee" +
      "fffffffff" +
      "ggggggggg" +
      "hhhhhhhhh" +
      "iiiiiiiii")
  end

  # Define column groups.
  def define_columns
    define_groupings(
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi" +
      "abcdefghi")
  end

  # Define block groups.
  def define_blocks
    define_groupings(
      "aaabbbccc" +
      "aaabbbccc" +
      "aaabbbccc" +
      "dddeeefff" +
      "dddeeefff" +
      "dddeeefff" +
      "ggghhhiii" +
      "ggghhhiii" +
      "ggghhhiii")
  end

  # Define a set of groups as specified by a 9x9 string stored in
  # row-major format.  Each position in the string represents a cell
  # on the grid.  Each character value in the string represents a
  # grouping of cells.  All cell positions with the same character
  # will be put in the same group.
  def define_groupings(string)
    groups = Hash.new { |h, k| h[k] = Group.new }
    group_ids = string.split(//)
    each do |cell|
      group_id = group_ids.shift
      next unless group_id =~ /^[a-zA-Z]$/
      groups[group_id] &lt;&lt; cell
    end
  end

  def say(message)
    puts message if @verbose
  end
end

class SudokuSolver
  def new_board(string)
    Board.new(true).parse(string)
  end

  def solve(string)
      board = new_board(string)
      puts board
      board.solve
      puts
      puts board
      puts
  end

  def run(args)
    if args.empty?
      puts "Usage: ruby sudoku.rb sud-files..."
      exit
    end

    args.each do |fn|
      puts "Solving #{fn} ----------------------------------------------"
      puts
      open(fn) do |f|
        solve(f.read)
      end
    end
  end
end

if __FILE__ == $0 then
  SudokuSolver.new.run(ARGV)
end
</code></pre>

</div>

<hr>


<p><a href="index.html">Back to Index</a></p>
      </div>
    </div>
  </body>
</html>

